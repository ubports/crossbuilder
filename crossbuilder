#!/bin/sh

# Copyright 2016 Canonical Ltd.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 3.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Florian Boucault <florian.boucault@canonical.com>

# TODO:
# NOW
# - document commands PACKAGE parameter

# LATER
# - mount home directory using technique from http://insights.ubuntu.com/2016/12/08/mounting-your-home-directory-in-lxd/
# - support snaps by using snapcraft
# - support per project custom build rules and custom deploy rules
# - options passed after the command failed with poor messages
# - option to pass configure flags (DEB_CONFIGURE_EXTRA_FLAGS)
# - add support for icecc/distcc
# - support Debian package format 3.0 (quilt) when no upstream tarball is available (ex: libqofono)
# - check if a newer version of the container's image is available
# - option to cleanup device (undeploy)

set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
LIGHT_RED='\033[1;31m'
LIGHT_GREEN='\033[1;32m'
NC='\033[0m'
ERROR_COLOR=$LIGHT_RED
POSITIVE_COLOR=$GREEN
PROGRAM_NAME=`basename $0`

display_help () {
    echo "Usage: $PROGRAM_NAME [options] [command]"
    echo ""
    echo "If no command is passed '$PROGRAM_NAME' will detect the package located in the current directory, "
    echo "create a container for it, download its dependencies, build it and deploy it to the connected device."
    echo ""
    echo "Available commands:"
    echo "    help          - Display this help."
    echo "    setup-lxd     - Setup LXD."
    echo "    new           - Create a container to build in."
    echo "    delete        - Delete a container."
#    echo "    list          - List existing containers."
    echo "    shell         - Executes a shell in a container (will create it if needed)."
    echo "    source        - Download a source package from the repositories."
    echo "    dependencies  - Download and install the dependencies of a package in a container (will create it if needed)"
    echo "    inst-foreign  - Download and install the given package and sets the 'Multi-arch: foreign' field on them"
    echo "    build         - Build a package in a container (will create it if needed)."
    echo "    clean         - Clean up the artifacts generated by a build."
    echo "    deploy        - Deploy built packages to a connected device."
#    echo "    undeploy      - Remove previously deployed packages from a connected device."
    echo ""
    echo "Options:"
#    echo "  --verbose       - Print verbose information."
    echo "  --packages       - Packages to deploy [by default: all the ones already installed on device]."
    echo "  --architecture   - Architecture to build for [defaults to architecture of connected device, if none then armhf]."
    echo "  --ubuntu         - Version of Ubuntu to build for [defaults to version of connected device, if none then 16.04]."
    echo "  --lxd-image      - LXD image to use [defaults to the ones provided by the Ubuntu SDK (example: ubuntu-sdk-16.04-amd64-armhf-dev)."
    echo "  --privileged     - Use a privileged container (disabled by default)."
    echo "  --ephemeral      - Build using a short-lived container (disabled by default)."
    echo "  --password       - User password of the device to deploy to [defaults to 0000]."
    echo "  --no-deb         - Do not build Debian packages and uses rsync to deploy the build artifacts."
    echo "  --deploy-path    - When deploying with --no-deb (rsync), installation path for the build artifacts [defaults to /]."
}


exec_device () {
    #echo adb shell "$@"
    adb shell "$@"
}

exec_container_root () {
    command="$@"
    #echo lxc exec $LXD_CONTAINER "$@"
    lxc exec $LXD_CONTAINER -- sh -c "$command"
}

exec_container () {
    command="$@"
    #echo lxc exec $LXD_CONTAINER "$@"
    lxc exec $LXD_CONTAINER -- su -l -c "cd $SOURCE_PATH_CONTAINER; $command" $USERNAME
}

variables () {
    DEBS_TARBALL_ROOT=debs
    if [ -n "$NEW_BUILD" ] ; then
        NEW_PACKAGE_VERSION=$PACKAGE_VERSION"local~"`date +%s`
    else
        LATEST_DEBS_TARBALL=$(ls -1 --sort=time $DEBS_TARBALL_ROOT_*.tar 2> /dev/null | head -n1)
        NEW_PACKAGE_VERSION=$(echo $LATEST_DEBS_TARBALL | sed "s/$DEBS_TARBALL_ROOT\_//" | sed "s/\.tar//")
    fi
    DEBS_TARBALL="$DEBS_TARBALL_ROOT"_"$NEW_PACKAGE_VERSION.tar"

    LXD_IMAGE_NO_DOT=$(echo $LXD_IMAGE | sed "s/\./-/")
    LXD_IMAGE_NO_PREFIX=$(echo $LXD_IMAGE_NO_DOT | sed "s/.*\://")
    LXD_IMAGE_NO_SDK=$(echo $LXD_IMAGE_NO_PREFIX | sed "s/ubuntu-sdk/usdk/")
    LXD_CONTAINER_COMPAT=builder-$PACKAGE-$LXD_IMAGE_NO_PREFIX
    LXD_CONTAINER=$PACKAGE-$LXD_IMAGE_NO_SDK
    LXD_CONTAINER=$(echo $LXD_CONTAINER | sed "s/\./-/")
    if lxc info $LXD_CONTAINER_COMPAT > /dev/null 2>&1 ; then
        echo "${ERROR_COLOR}Containers are switching to shorter names, please manually delete your container: lxc delete -f $LXD_CONTAINER_COMPAT${NC}"
        echo "${ERROR_COLOR}Next time it will be called $LXD_CONTAINER.${NC}"
        LXD_CONTAINER=$LXD_CONTAINER_COMPAT
    fi

    # LXD container name can only have HOST_NAME_MAX characters
    LXD_CONTAINER=$(echo $LXD_CONTAINER | cut -c 1-$((`getconf HOST_NAME_MAX` - 1)))
    LXD_CONTAINER_FAILURE_MSG="${ERROR_COLOR}Failed to start container. See 'lxc info ${LXD_CONTAINER} --show-log'${NC}"
    USERNAME=`id --user --name`
    GROUPNAME=$USERNAME
    if [ -n "$ENCRYPTED_HOME" ] || [ -n "$FORCE_PRIVILEGED" ] ; then
        USERID=`id --user`
        GROUPID=`id --group`
    else
        USERID=150000
        GROUPID=150000
    fi
    USERDIR=/home/$USERNAME
    SOURCE_REPOSITORY=$USERDIR/source_repository
    SCRIPT_DIR=`dirname $0`
    CREATE_REPO_SCRIPT=create_repository.sh
    PARALLEL_BUILD=$((`nproc` + 1))
    MOUNTED_DIRECTORY=$PWD
    MOUNT_POINT=$USERDIR/$PACKAGE
    SOURCE_PATH_LOCAL=$MOUNTED_DIRECTORY
    SOURCE_PATH_CONTAINER=$MOUNT_POINT
    POST_DEPLOY_SCRIPT=.crossbuilder/post_deploy
    HOST_FARCH=$(dpkg-architecture -f -a$TARGET_ARCH -qDEB_BUILD_MULTIARCH)
    TARGET_FARCH=$(dpkg-architecture -f -a$TARGET_ARCH -qDEB_HOST_MULTIARCH)
    if [ "$(dpkg-architecture -f -a$TARGET_ARCH -qDEB_BUILD_ARCH)" != "$TARGET_ARCH" ]; then
        DEB_BUILD_PROFILES="cross nocheck"
        EXTRA_DEB_BUILD_OPTIONS="nocheck"
    else
        DEB_BUILD_PROFILES=""
        EXTRA_DEB_BUILD_OPTIONS=""
    fi
}

check_lxd_accessible () {
    # /bin/lxd is replaced with a script which tells you to install the lxd snap
    # on later versions of Ubuntu.
    LXD=`which lxd`
    if (grep 'snap install lxd' "$LXD" >/dev/null) && [ ! -f /snap/bin/lxd ] ; then
        $LXD
        exit 1
    fi

    if ! lxc info > /dev/null 2>&1 ; then
        echo "${ERROR_COLOR}LXD was installed but is not accessible."
        echo "Check the 'lxd' group exists and you are a member, then restart your computer."
        echo "For more information, run 'lxc info'.${NC}"
        exit 1
    fi
}

lxd_has_image_or_container () {
    CONTAINER_COUNT=$(lxc list | wc -l)
    IMAGE_COUNT=$(lxc image list | wc -l)
    if [ $CONTAINER_COUNT = "3" ] && [ $IMAGE_COUNT = "3" ]; then
        return 1
    fi

    return 0
}

is_subuid_setup () {
    if ! grep "root:1000:1" /etc/subuid > /dev/null ; then
        return 1
    fi
    if ! grep "root:1000:1" /etc/subgid > /dev/null ; then
        return 1
    fi
    return 0
}

ensure_lxd_subuid () {
    if ! is_subuid_setup ; then
        echo "${ERROR_COLOR}LXD requires subuid to be setup adequately to mount directories in containers.${NC}"
        echo "${POSITIVE_COLOR}Would you like to do that now? (y/n) ${NC}"
        read REPLY
        echo
        if [ "$REPLY" = y ]
        then
            sudo usermod --add-subuids 1000-1000 root
            sudo usermod --add-subgids 1000-1000 root
            if which service > /dev/null ; then
                sudo service lxd restart
            elif which snap > /dev/null && snap connections lxd > /dev/null ; then
                sudo snap restart lxd
            else
                sudo systemctl restart lxd
            fi
        else
            echo "${ERROR_COLOR}Unable to set up LXD for use in crossbuilder. Subuid setup refused.${NC}"
            exit 1
        fi
    fi
}

setup_lxd () {
    echo "${POSITIVE_COLOR}Setting up LXD.${NC}"

    if [ "$(lsb_release -cs)" = "xenial" ]; then
        echo "${ERROR_COLOR}You are running Ubuntu 16.04 (xenial).${NC}"
        echo "We have found an issue where the default LXD setup on 16.04 does not allow"
        echo "containers to connect to the internet."
        echo "In the following dialog, set up an IPv4 and IPv6 subnet for your bridge so they"
        echo "will be able to connect to the internet. The default options presented will do"
        echo "this for you."
        echo "Press Enter to start"
        read KEY
        unset $KEY
        # Ubuntu 16.04 specific workaround to set up
        sudo dpkg-reconfigure -p medium lxd
    fi

    if [ -n "$ENCRYPTED_HOME" ] ; then
        echo -n "${ERROR_COLOR}Your home folder is encrypted. $PROGRAM_NAME will use priviledged "
        echo -n "LXD containers and the default storage backend (slower).\n${NC}"
        sudo lxd init --auto
    else
        echo -n "${POSITIVE_COLOR}Would you like to setup LXD with ZFS in your home directory? (y/n) \n${NC}"
        echo -n "This is recommended for faster operation, and also in case there is not enough "
        echo -n "space in your / partition. \n"
        read REPLY
        echo
        if [ "$REPLY" = y ]
        then
            if ! which zpool > /dev/null ; then
                echo "${POSITIVE_COLOR}Installing ZFS.${NC}"
                sudo apt-get install -y zfsutils-linux
            fi
            LXD_POOL=~/zfs/lxd.img
            echo "${POSITIVE_COLOR}Creating file $LXD_POOL to contain all of LXD's images and containers.${NC}"
            mkdir -p `dirname $LXD_POOL`
            truncate -s 32G $LXD_POOL
            sudo zpool create -f lxd $LXD_POOL
            sudo lxd init --auto --storage-backend zfs --storage-pool lxd
            # add automatic mount of zfs pool upon boot
            echo "zpool import -c /etc/zfs/zpool.cache -aN" | sudo tee /etc/rc.local
        else
            sudo lxd init --auto
        fi
    fi
}

config_container_dir_mount () {
    if ! lxc config device get $LXD_CONTAINER current_dir_mount disk 2> /dev/null ; then
        echo "${POSITIVE_COLOR}Mounting $MOUNTED_DIRECTORY in container.${NC}"
        lxc config device add $LXD_CONTAINER current_dir_mount disk source=$MOUNTED_DIRECTORY path=$MOUNT_POINT
    else
        lxc config device set $LXD_CONTAINER current_dir_mount source $MOUNTED_DIRECTORY
    fi
}

start_container () {
    STATUS=`lxc info ${LXD_CONTAINER} | grep 'Status' | awk '{print $2}'`
    if [ $STATUS = 'Stopped' ]; then
        # lxc start may give a failure code. It also may not, so we check
        # again in a bit.
        if ! lxc start $LXD_CONTAINER; then
            echo $LXD_CONTAINER_FAILURE_MSG
            exit 1
        fi
    fi

    # Unfortunately we need to check again. We check for Started this time
    # because the monitor may be hung with the container failing, which will
    # give us much different output
    STATUS=`lxc info ${LXD_CONTAINER} | grep 'Status' | awk '{print $2}'`
    if [ "$STATUS" != 'Running' ]; then
        echo $LXD_CONTAINER_FAILURE_MSG
        exit 1
    fi
}

create_container () {
    lxc remote --protocol=simplestreams --public=true --accept-certificate=true add ubports-sdk https://sdk-images.ubports.com || true
    lxc init $LXD_IMAGE $LXD_CONTAINER $EPHEMERAL_FLAG
    if [ -n "$ENCRYPTED_HOME" ] || [ -n "$FORCE_PRIVILEGED" ] ; then
        lxc config set $LXD_CONTAINER security.privileged true
    else
        if [ "$(lxc --version | cut -f1 -d. )" -ge "3" ]; then
            IDMAP="lxc.idmap"
        else
            IDMAP="lxc.id_map"
        fi
        printf "$IDMAP = g $GROUPID `id --group` 1\n$IDMAP = u $USERID `id --user` 1" | lxc config set $LXD_CONTAINER raw.lxc -
    fi
    lxc start $LXD_CONTAINER
    lxc exec --env GROUPID=$GROUPID --env GROUPNAME=$GROUPNAME $LXD_CONTAINER -- addgroup --gid $GROUPID $GROUPNAME
    lxc exec --env GROUPID=$GROUPID --env USERNAME=$USERNAME --env USERID=$USERID $LXD_CONTAINER -- adduser --disabled-password --gecos "" --uid $USERID --gid $GROUPID $USERNAME
    lxc exec --env USERNAME=$USERNAME $LXD_CONTAINER -- usermod -aG sudo $USERNAME
    exec_container_root "sed -i 's/ENV_PATH.*PATH=/ENV_PATH\tPATH=\/usr\/lib\/ccache:/' /etc/login.defs"
    # wait for the container's network connection
    check_for_container_network
    if [ "${TARGET_UBUNTU}" = "15.04" ]; then
        # Fixup the SDK images; we should really try to get new SDK images for ubports
        exec_container_root "sed -i 's/archive.ubuntu.com/old-releases.ubuntu.com/g' /etc/apt/sources.list"
        exec_container_root "sed -i 's/ports.ubuntu.com\/ubuntu-ports/old-releases.ubuntu.com\/ubuntu/g' /etc/apt/sources.list"
        exec_container_root "add-apt-repository -y ppa:ubports-developers/overlay"
        exec_container_root "add-apt-repository 'deb http://repo.ubports.com vivid main' >> /etc/apt/sources.list"
    fi
    wget -qO - "http://repo.ubports.com/keyring.gpg" | exec_container_root apt-key add -
    exec_container_root apt update
    exec_container_root apt install -y sudo debhelper ccache software-properties-common devscripts equivs qemu-user-static
    exec_container_root adduser $USERNAME sudo
    # set empty password for the user
    exec_container_root passwd --delete $USERNAME
    # FIXME: these should probably be set in the image already
    if [ "$HOST_FARCH" != "$TARGET_FARCH" ]; then
        QT_SELECT_ARCH="$HOST_FARCH-$TARGET_FARCH"
    else
        QT_SELECT_ARCH=$HOST_FARCH
    fi
    exec_container_root "printf 'export PKG_CONFIG_PATH=/usr/lib/$TARGET_FARCH/pkgconfig\n\
export QT_SELECT=qt5-$QT_SELECT_ARCH\n\
export CC=$TARGET_FARCH-gcc\n\
export CXX=$TARGET_FARCH-g++\n\
' >> /etc/profile.d/clickvars.sh"
    # FIXME: image should have environment variables set from executing:
    # dpkg-architecture --print-set --target-arch armhf
}

ensure_container () {
    # setup the building container
    if lxc info $LXD_CONTAINER > /dev/null 2>&1 ; then
        echo "${POSITIVE_COLOR}LXD container $LXD_CONTAINER already exists.${NC}"
        start_container
    else
        echo "${POSITIVE_COLOR}Creating LXD container $LXD_CONTAINER using $LXD_IMAGE.${NC}"
        create_container
    fi

    config_container_dir_mount
}

delete_container () {
    echo "${POSITIVE_COLOR}Deleting LXD container $LXD_CONTAINER.${NC}"
    lxc delete -f $LXD_CONTAINER
}

shell_container () {
    echo "${POSITIVE_COLOR}Entering shell in LXD container $LXD_CONTAINER.${NC}"
    lxc exec $LXD_CONTAINER -- su --login $USERNAME
}

stop_container () {
    echo "${POSITIVE_COLOR}Stopping LXD container $LXD_CONTAINER.${NC}"
    lxc stop -f $LXD_CONTAINER
}

enable_overlay_source () {
    OVERLAY_APT="/etc/apt/sources.list.d/ci-train-ppa-service-ubuntu-stable-phone-overlay-vivid.list"
    if exec_container_root "grep '#.*deb-src' $OVERLAY_APT" ; then
        exec_container_root "sed -i 's/#.*deb-src/deb-src/' $OVERLAY_APT"
        exec_container_root apt-get update --allow-unauthenticated
    fi
}

get_source_package () {
    echo "${POSITIVE_COLOR}Downloading source package $PACKAGE for Ubuntu $TARGET_UBUNTU.${NC}"

    # cleanup source repository potentially setup by install_dependencies before
    exec_container rm -f $USERDIR/dependencies_installed
    exec_container_root add-apt-repository --remove --enable-source \"deb file://$SOURCE_REPOSITORY/ /\"
    exec_container_root "sudo rm -f /etc/apt/preferences.d/localrepo.pref"

    enable_overlay_source

    if ! lxc exec $LXD_CONTAINER -- su -l -c "cd $MOUNT_POINT; apt-get source --only-source $PACKAGE" $USERNAME ; then
        echo "${ERROR_COLOR}No source package exists with the name $PACKAGE.${NC}"
        echo "${ERROR_COLOR}Deleting container $LXD_CONTAINER.${NC}"
        lxc delete -f $LXD_CONTAINER
        exit 1
    fi

    PACKAGE_VERSION=`dpkg-parsechangelog --show-field Version -l $PACKAGE*/debian/changelog`
    exec_container "mv $PACKAGE*.orig.tar.* $PACKAGE*diff.* $PACKAGE*debian.tar* $PACKAGE*.dsc $USERDIR/" || true
    mv $PACKAGE-*/* .
    mv $PACKAGE-*/.[!.]* . || true
    rmdir $PACKAGE-*
    echo "${POSITIVE_COLOR}Source code for $PACKAGE is now available in $PACKAGE/.${NC}"
    VCS=$(grep -i vcs debian/control | grep --invert-match Vcs-Browser)
    if [ "$VCS" != "" ] ; then
        echo "${POSITIVE_COLOR}'$PACKAGE' packaging is versioned and available at $VCS${NC}"
    fi
}

backup_changelog () {
    cp debian/changelog /tmp/$PACKAGE-changelog.orig
}

restore_changelog () {
    mv /tmp/$PACKAGE-changelog.orig debian/changelog
}

backup_jenkinsfile_and_sourceloc() {
    if [ -f Jenkinsfile ]; then
        mv Jenkinsfile /tmp/$PACKAGE-Jenkinsfile
    fi
    if [ -f ubports.source_location ]; then
        mv ubports.source_location /tmp/$PACKAGE-ubports.source_location
    fi
}

restore_jenkinsfile_and_sourceloc() {
    if [ -f /tmp/$PACKAGE-Jenkinsfile ]; then
        mv /tmp/$PACKAGE-Jenkinsfile Jenkinsfile
    fi
    if [ -f /tmp/$PACKAGE-ubports.source_location ]; then
        mv /tmp/$PACKAGE-ubports.source_location ubports.source_location
    fi
}

workaround_multi_arch_deps () {
    for package in python3-setuptools python3-flake8 dh_translations xvfb qtdeclarative5-doc-html qtbase5-doc-html
    do
        sed -i "s/${package}\([, ]\)/${package}:native\1/" debian/control
    done
}

ensure_upstream_tarball () {
    if [ -f ubports.source_location ]; then
        SOURCE_URL=$(cat ubports.source_location | awk 'BEGIN{ RS = "" ; FS = "\n" }{print $1}')
        TARGET_FILE=$(cat ubports.source_location | awk 'BEGIN{ RS = "" ; FS = "\n" }{print $2}')
        echo "${POSITIVE_COLOR}Downloading upstream source tarball of $PACKAGE in container to $TARGET_FILE.${NC}"
        exec_container "cd $USERDIR && wget --continue -O $TARGET_FILE $SOURCE_URL"
    elif grep quilt debian/source/format > /dev/null 2>&1 ; then
        echo "${POSITIVE_COLOR}Downloading upstream tarball of $PACKAGE in container.${NC}"
        enable_overlay_source
        # FIXME: try using dget instead so that we can specify a precise version
        exec_container "cd $USERDIR && apt-get source --download-only --allow-unauthenticated $PACKAGE"
    fi
}

install_dependencies () {
    echo "${POSITIVE_COLOR}Installing $TARGET_ARCH (host $HOST_ARCH) build dependencies for $PACKAGE in container $LXD_CONTAINER.${NC}"
    # install build dependencies in container
    if ! exec_container test -e $USERDIR/dependencies_installed ; then
        ensure_upstream_tarball
        echo "${POSITIVE_COLOR}Installing $TARGET_ARCH build dependencies for $PACKAGE in container $LXD_CONTAINER.${NC}"
        exec_container mkdir -p $SOURCE_REPOSITORY
        lxc file push $SCRIPT_DIR/$CREATE_REPO_SCRIPT $LXD_CONTAINER$SOURCE_REPOSITORY/

        backup_changelog
        backup_jenkinsfile_and_sourceloc
        trap restore_changelog HUP INT TERM QUIT
        exec_container dch -v $NEW_PACKAGE_VERSION \'\'
        workaround_multi_arch_deps
        if ! exec_container "DEB_BUILD_PROFILES='$DEB_BUILD_PROFILES' dpkg-buildpackage -S -nc -d -I -Iobj-* -Idebian/tmp/* -I.bzr*" ; then
            restore_changelog
            restore_jenkinsfile_and_sourceloc
            exit 1
        fi
        restore_jenkinsfile_and_sourceloc
        if ! exec_container "mv -f $USERDIR/$PACKAGE*.* $SOURCE_REPOSITORY/" ; then
            exec_container "rm -f $USERDIR/$PACKAGE*.*"
        fi
        exec_container $SOURCE_REPOSITORY/$CREATE_REPO_SCRIPT $SOURCE_REPOSITORY
        exec_container_root add-apt-repository --enable-source \"deb file://$SOURCE_REPOSITORY/ /\"
        exec_container_root "printf 'Package: *\nPin: release o=local\nPin-Priority: 2000' | sudo tee /etc/apt/preferences.d/localrepo.pref"
        exec_container_root apt-get update --allow-unauthenticated
        PROFILES_OPTION=$(echo "$DEB_BUILD_PROFILES" | sed "s/ /,/")
        if ! exec_container_root "mk-build-deps -t 'apt-get -o Debug::pkgProblemResolver=yes -y' -i --host-arch $TARGET_ARCH $SOURCE_PATH_CONTAINER/debian/control"; then
            restore_changelog
            exit 1
        fi

        restore_changelog

        # workaround various issues with qmake cross compilation
        # FIXME: this should be integrated in the binary package qt5-qmake-$TARGET_FARCH
        # from source package qtbase-opensource-src
        if exec_container test -e /usr/bin/qt5-qmake-$TARGET_FARCH ; then
            exec_container_root "printf '/usr/lib/$HOST_FARCH/qt5/$TARGET_FARCH/bin\n/usr/lib/$HOST_FARCH/qt5/bin\n/usr/lib/$HOST_FARCH\n' > /usr/share/qtchooser/qt5-$HOST_FARCH-$TARGET_FARCH.conf"
            exec_container_root mkdir -p /usr/lib/$HOST_FARCH/qtchooser
            exec_container_root ln -f -s ../../../share/qtchooser/qt5-$HOST_FARCH-$TARGET_FARCH.conf /usr/lib/$HOST_FARCH/qtchooser/qt5-$TARGET_FARCH.conf
            exec_container_root ln -f -s ../../../share/qtchooser/qt5-$HOST_FARCH-$TARGET_FARCH.conf /usr/lib/$HOST_FARCH/qtchooser/5-$TARGET_FARCH.conf
            exec_container_root mkdir -p /usr/lib/$HOST_FARCH/qt5/$TARGET_FARCH/bin
            exec_container_root ln -f /usr/bin/qt5-qmake-$TARGET_FARCH /usr/lib/$HOST_FARCH/qt5/$TARGET_FARCH/bin/qmake
        fi

        exec_container touch $USERDIR/dependencies_installed
    else
        echo "${POSITIVE_COLOR}$TARGET_ARCH build dependencies for $PACKAGE already installed in container $LXD_CONTAINER.${NC}"
    fi;
}

install_foreign () {
    for dep in "$@"
    do
        echo "Installing $dep"
        exec_container "mkdir -p foreign && cd foreign && apt-get download $dep && dpkg-deb -R $dep* tmp"
        exec_container "grep -vi '^multi' foreign/tmp/DEBIAN/control > foreign/tmp/DEBIAN/control.tmp"
        exec_container "mv foreign/tmp/DEBIAN/control.tmp foreign/tmp/DEBIAN/control"
	exec_container "echo 'Multi-Arch: foreign' >> foreign/tmp/DEBIAN/control"
        exec_container "cd foreign && dpkg-deb -b tmp $dep*"
        exec_container_root "dpkg -i $SOURCE_PATH_CONTAINER/foreign/$dep*"
        exec_container "rm -r foreign/"
    done
}

build_deb () {
    # build package in container
    echo "${POSITIVE_COLOR}Building $PACKAGE for $TARGET_ARCH in parallel (-j$PARALLEL_BUILD).${NC}"
#    exec_container "rm -f ../*.deb"
    exec_container "rm -f debian/*.debhelper.log"
    backup_changelog
    trap restore_changelog HUP INT TERM QUIT

    exec_container dch -v $NEW_PACKAGE_VERSION \'\'
    if ! exec_container "DEB_BUILD_PROFILES='$DEB_BUILD_PROFILES' DEB_BUILD_OPTIONS='parallel=$PARALLEL_BUILD nostrip $EXTRA_DEB_BUILD_OPTIONS' dpkg-buildpackage --target-arch $TARGET_ARCH -d -us -uc -nc -I -Iobj-* -Idebian/tmp/* -I.bzr* -b" ; then
        restore_changelog
        exit 1
    fi
    restore_changelog

    # transfer resulting debian packages to local machine
    echo "${POSITIVE_COLOR}Packing build artifacts in $DEBS_TARBALL.${NC}"
    rm -f $DEBS_TARBALL_ROOT*
    exec_container "tar cf ../$DEBS_TARBALL ../*.deb"
    lxc file pull $LXD_CONTAINER$USERDIR/$DEBS_TARBALL .
    exec_container "rm ../*.deb ../*.changes ../$DEBS_TARBALL"
}

build_make_install () {
    echo "${POSITIVE_COLOR}Building $PACKAGE for $TARGET_ARCH in parallel (-j$PARALLEL_BUILD).${NC}"
    exec_container "rm -f debian/*.debhelper.log"
    exec_container "DEB_BUILD_PROFILES='$DEB_BUILD_PROFILES' DEB_BUILD_OPTIONS='parallel=$PARALLEL_BUILD nostrip $EXTRA_DEB_BUILD_OPTIONS' fakeroot debian/rules install"
}

build () {
    if [ -n "$NO_DEB" ] ; then
        build_make_install
    else
        build_deb
    fi
}

copy_build_to_container () {
    PREVIOUS_BUILD_FOLDER=$1
    PREVIOUS_DEBS_TARBALL=$2
    echo "${POSITIVE_COLOR}Copying and extracting $PREVIOUS_DEBS_TARBALL from $PREVIOUS_BUILD_FOLDER into container $LXD_CONTAINER.${NC}"
    exec_container mkdir -p $SOURCE_REPOSITORY
    lxc file push $PREVIOUS_BUILD_FOLDER/$PREVIOUS_DEBS_TARBALL $LXD_CONTAINER$SOURCE_REPOSITORY/
    exec_container "tar xf $SOURCE_REPOSITORY/$PREVIOUS_DEBS_TARBALL --directory $SOURCE_REPOSITORY/"
}

clean () {
    echo "${POSITIVE_COLOR}Cleaning previous build of $PACKAGE for $TARGET_ARCH.${NC}"
    exec_container debian/rules clean
}

check_for_container_network() {
    NETWORK_UP=0
    for i in `seq 1 10`
    do
        if lxc info $LXD_CONTAINER | grep -e "eth0.*inet\b" > /dev/null 2>&1 ; then
            NETWORK_UP=1
            break
        fi
        sleep 1
    done
    if [ $NETWORK_UP -ne 1 ] ; then
        echo "${ERROR_COLOR}Container is not connected to the Internet.${NC}"
        exit 1
    fi

}

check_for_device_network() {
    NETWORK_UP=0
    for i in `seq 1 5`
    do
        if adb shell ping -c1 -w1 google.com | grep PING > /dev/null 2>&1 ; then
            NETWORK_UP=1
            break
        fi
    done
    if [ $NETWORK_UP -ne 1 ] ; then
        echo "${ERROR_COLOR}The connected device is not connected to the Internet.${NC}"
        exit 1
    fi
}

deploy_deb () {
    if ! test -e $DEBS_TARBALL ; then
        echo "${ERROR_COLOR}No Debian packages ($DEBS_TARBALL) to deploy to device. Run $PROGRAM_NAME build first.${NC}"
        exit 1
    fi

    echo "${POSITIVE_COLOR}Transferring Debian packages to device.${NC}"
    # tranfer debian packages to device
    exec_device mkdir -p /tmp/repo
    adb push $DEBS_TARBALL /tmp/repo/
    exec_device "cd /tmp/repo && tar xvf /tmp/repo/$DEBS_TARBALL && rm -f /tmp/repo/$DEBS_TARBALL_ROOT*"

    # install debian packages on device
    if [ ! -z "$PACKAGES_TO_DEPLOY" ] ; then
        echo "${POSITIVE_COLOR}Installing manually specified packages:" $PACKAGES_TO_DEPLOY${NC}
        DPKG_ARGS=""
        for package in $PACKAGES_TO_DEPLOY ; do
            DPKG_ARGS="$DPKG_ARGS /tmp/repo/$package"_"$NEW_PACKAGE_VERSION"_"$TARGET_ARCH.deb"
        done
        exec_device SUDO_ASKPASS=/tmp/askpass.sh sudo -A dpkg -i $DPKG_ARGS
    else
        check_for_device_network
        echo "${POSITIVE_COLOR}Upgrading packages already installed on device with newly built ones.${NC}"
        # create local deb repository on device
        rm -f $CREATE_REPO_SCRIPT
        if ! adb pull /tmp/repo/$CREATE_REPO_SCRIPT 2> /dev/null ; then
            adb push $SCRIPT_DIR/$CREATE_REPO_SCRIPT /tmp/repo/
            exec_device /tmp/repo/$CREATE_REPO_SCRIPT /tmp/repo
            exec_device "printf 'deb file:/tmp/repo/ /\n' > /tmp/repo/sources.list"
            exec_device "cp /etc/apt/sources.list /tmp/repo/all.list"
            exec_device "cat /tmp/repo/sources.list >> /tmp/repo/all.list"
            SERIES=$(adb shell lsb_release -cs | tr -d '\r')
            exec_device "printf 'Package: *\nPin: release o=local\nPin-Priority: 2000\n\nPackage: *\nPin: release a=$SERIES*\nPin-Priority: 50' | SUDO_ASKPASS=/tmp/askpass.sh sudo -A tee /etc/apt/preferences.d/localrepo.pref"
#            exec_device SUDO_ASKPASS=/tmp/askpass.sh sudo -A apt-get update
        else
            exec_device /tmp/repo/$CREATE_REPO_SCRIPT /tmp/repo
        fi;

        exec_device "SUDO_ASKPASS=/tmp/askpass.sh sudo -A sed -i '/Pin-Priority/c\Pin-Priority: 50' /etc/apt/preferences.d/extra-ppas.pref"
        exec_device SUDO_ASKPASS=/tmp/askpass.sh sudo -A  apt-get update -o Dir::Etc::sourcelist="/tmp/repo/sources.list" -o Dir::Etc::sourceparts="-" -o APT::Get::List-Cleanup="0"
        exec_device SUDO_ASKPASS=/tmp/askpass.sh sudo -A apt-get dist-upgrade -o Dir::Etc::sourcelist="/tmp/repo/all.list" --yes --force-yes
        exec_device "SUDO_ASKPASS=/tmp/askpass.sh sudo -A sed -i '/Pin-Priority/c\Pin-Priority: 1001' /etc/apt/preferences.d/extra-ppas.pref"
    fi;
}

deploy_make_install () {
    echo "${POSITIVE_COLOR}Transferring build artifacts to device.${NC}"
    if [ -z "$PACKAGES_TO_DEPLOY" ] ; then
        PACKAGES_TO_DEPLOY=$(grep Package debian/control | cut -d ' ' -f 2)
    fi

    for binary_package in $PACKAGES_TO_DEPLOY
    do
        FOLDERS_TO_DEPLOY="$FOLDERS_TO_DEPLOY debian/$binary_package/"
        # clean up build artifacts from a potential previous Debian package build
        rm -rf debian/$binary_package/DEBIAN
    done

    if [ -z "$DEPLOY_PATH" ] ; then
        DEPLOY_PATH="/"
    fi

    sync_with_device $FOLDERS_TO_DEPLOY $DEPLOY_PATH
}

deploy_to_device () {
    DEVICE_STATE=`adb get-state`
    if [ "$DEVICE_STATE" != "device" ] ; then
        echo "${ERROR_COLOR}No device connected to deploy to.${NC}"
        exit 1
    fi;

    # setup sudo on device
    exec_device "printf '#\041/bin/sh\necho $DEVICE_PASSWORD' >/tmp/askpass.sh"
    exec_device chmod +x /tmp/askpass.sh

    # check password is correct
    exec_device SUDO_ASKPASS=/tmp/askpass.sh sudo -A touch /tmp/password_ok
    if adb pull /tmp/password_ok ; then
        rm -f password_ok
        exec_device SUDO_ASKPASS=/tmp/askpass.sh sudo -A rm -f /tmp/password_ok
    else
        echo "${ERROR_COLOR}Device password incorrect. Use --password to pass the correct one or write it in $DEVICE_PASSWORD_FILE.${NC}"
        exit 1
    fi

    exec_device SUDO_ASKPASS=/tmp/askpass.sh sudo -A mount -o remount,rw /

    if [ -n "$NO_DEB" ] ; then
        deploy_make_install
    else
        deploy_deb
    fi

    # execute post deploy
    if test -e $SOURCE_PATH_LOCAL/$POST_DEPLOY_SCRIPT ; then
        echo "${POSITIVE_COLOR}Execute project specific post deploy script ($POST_DEPLOY_SCRIPT).${NC}"
        adb push $SOURCE_PATH_LOCAL/$POST_DEPLOY_SCRIPT /tmp
        exec_device sh /tmp/$(basename $POST_DEPLOY_SCRIPT)
    else
        echo "${POSITIVE_COLOR}If a script named $POST_DEPLOY_SCRIPT existed, it would be executed on device after every deploy.${NC}"
    fi
}

MISSING_PACKAGES=
if ! which dpkg > /dev/null ; then
    MISSING_PACKAGES="dpkg"
fi
if ! which dpkg-parsechangelog > /dev/null ; then
    MISSING_PACKAGES="dpkg-dev $MISSING_PACKAGES"
fi
if ! which adb > /dev/null ; then
    MISSING_PACKAGES="android-tools-adb $MISSING_PACKAGES"
fi

if [ ! -z "$MISSING_PACKAGES" ] ; then
    echo "${POSITIVE_COLOR}$PROGRAM_NAME depends on $MISSING_PACKAGES. Installing:${NC}"
    echo "sudo apt install $MISSING_PACKAGES"
    sudo apt install $MISSING_PACKAGES
fi

if stat --file-system $HOME | grep ecrypt ; then
    ENCRYPTED_HOME=1
fi

if [ -e "/snap/bin/lxc" ]; then
    FORCE_PRIVILEGED=1
fi

if ! which lxd > /dev/null ; then
    echo "${POSITIVE_COLOR}$PROGRAM_NAME uses LXD to download dependencies and build."
    echo -n "${POSITIVE_COLOR}Would you like to install LXD? (y/n) ${NC}"
    read REPLY
    echo
    if [ "$REPLY" = y ]
    then
        echo "sudo apt-get install -y lxd lxd-client"
        sudo apt-get install -y lxd lxd-client
        setup_lxd
        ensure_lxd_subuid
        newgrp lxd
	    sudo usermod -a -G lxd $(whoami)
        echo "${ERROR_COLOR}LXD is now setup but will only work after you restart your computer.${NC}"
        exit 0
    else
        echo "${ERROR_COLOR}$PROGRAM_NAME will not work without LXD. Bye.$OPTION${NC}"
        exit 1
    fi
fi

check_lxd_accessible
ensure_lxd_subuid

HOST_ARCH=`dpkg --print-architecture`
TARGET_ARCH=armhf
TARGET_UBUNTU=16.04

DEVICE_PASSWORD=0000
DEVICE_PASSWORD_FILE=~/.config/crossbuilder/device_password
[ -e "$DEVICE_PASSWORD_FILE" ] && DEVICE_PASSWORD=$(cat $DEVICE_PASSWORD_FILE)

DEVICE_STATE=`adb get-state || true`
if [ "$DEVICE_STATE" = "device" ] ; then
    DEVICE_ARCH=$(adb shell "dpkg --print-architecture" | tr -d '\r')
    if echo "$DEVICE_ARCH" | grep -vq "not found"; then
        TARGET_ARCH=$DEVICE_ARCH
        TARGET_UBUNTU=$(adb shell "lsb_release --release --short" | tr -d '\r')
        DEPLOY=true
    fi
fi;

while [ "$1" != "" ]; do
    OPTION=`echo $1 | awk -F= '{print $1}'`
    VALUE=`echo $1 | awk -F= '{print $2}'`
    case $1 in
        -*)
            case $OPTION in
            --packages)
                PACKAGES_TO_DEPLOY=$VALUE
            ;;
            --architecture)
                TARGET_ARCH=$VALUE
            ;;
            --ubuntu)
                TARGET_UBUNTU=$VALUE
            ;;
            --lxd-image)
                LXD_IMAGE=$VALUE
            ;;
            --password)
                DEVICE_PASSWORD=$VALUE
            ;;
            --no-deb)
                NO_DEB=1
            ;;
            --deploy-path)
                DEPLOY_PATH=$VALUE
            ;;
            --privileged)
                FORCE_PRIVILEGED=1
            ;;
            --ephemeral)
                EPHEMERAL_CONTAINER=1
                EPHEMERAL_FLAG=--ephemeral
            ;;
            --help)
                display_help
                exit 0
            ;;
            *)
                display_help
                echo ""
                echo "${ERROR_COLOR}error: unknown option: $OPTION${NC}"
                exit 1
            ;;
            esac
            shift
        ;;
        *)
            break
        ;;
    esac
done

if [ -z "$LXD_IMAGE" ] ; then
    LXD_IMAGE=ubports-sdk:ubuntu-sdk-$TARGET_UBUNTU-$HOST_ARCH-$TARGET_ARCH-dev
fi

COMMAND=$1
if [ -n "$COMMAND" ] ; then
    shift
fi

if [ "$COMMAND" = "help" ] ; then
    display_help
    exit 0
fi

check_command_parameter_count () {
    MIN_PARAMETERS=$1
    MAX_PARAMETERS=$2
    COUNT=$(echo $PARAMETERS | wc -w)
    if  [ -n $MIN_PARAMETERS ] && [ $COUNT -lt $MIN_PARAMETERS ] ; then
        display_help
        echo ""
        echo "${ERROR_COLOR}Command '$COMMAND' requires a minimum of $MIN_PARAMETERS parameters. $COUNT passed.${NC}"
        exit 1
    fi
    if [ -n $MAX_PARAMETERS ] && [ $COUNT -gt $MAX_PARAMETERS ] ; then
        display_help
        echo ""
        echo "${ERROR_COLOR}Command '$COMMAND' accepts at most $MAX_PARAMETERS parameters. $COUNT passed.${NC}"
        exit 1
    fi
}

detect_package () {
    if test -e debian/changelog ; then
        PACKAGE=`dpkg-parsechangelog --show-field Source`
        PACKAGE_VERSION=`dpkg-parsechangelog --show-field Version`
    fi
}

check_changelog_exists () {
    if ! test -e debian/changelog ; then
        echo "${ERROR_COLOR}No debian/changelog found in $PWD.${NC}"
        echo "If the source code is not available it can be automatically downloaded from the repositories using the 'source' command."
        exit 1
    fi
}

enter_package () {
    if [ -n "$ORIGINAL_DIRECTORY" ] ; then
        cd $ORIGINAL_DIRECTORY
    fi
    ORIGINAL_DIRECTORY=$PWD
    PACKAGE=$1
    if [ -n "$PACKAGE" ] ; then
        if ! cd $PACKAGE ; then
            echo "${ERROR_COLOR}No directory $PACKAGE.${NC}"
            exit 1
        fi
    fi
}

enter_or_detect_package () {
    PACKAGE=$1
    if [ -n "$PACKAGE" ] ; then
        enter_package $PACKAGE
        detect_package
        check_changelog_exists
    else
        detect_package
        check_changelog_exists
    fi
}

enter_new_or_detect_package() {
    PACKAGE=$1
    if [ -n "$PACKAGE" ] ; then
        mkdir -p $PACKAGE
        enter_package $PACKAGE
        detect_package
    else
        detect_package
        check_changelog_exists
    fi
}

if [ -z "$COMMAND" ] ; then
    NEW_BUILD=1
    detect_package
    check_changelog_exists
    variables
    if [ "$DEPLOY" ] ; then
        echo "${POSITIVE_COLOR}Building $PACKAGE for $TARGET_ARCH and deploying to device.${NC}"
    else
        echo "Could not find a device, will not deploy"
        echo "${POSITIVE_COLOR}Building $PACKAGE for $TARGET_ARCH.${NC}"
    fi
    ensure_container
    install_dependencies
    build
    if [ "$DEPLOY" ] ; then
        deploy_to_device
    fi
    stop_container
else
    PARAMETERS=$@
    case "$COMMAND" in
        setup-lxd)
            check_command_parameter_count 0 0
            if lxd_has_image_or_container ; then
                echo "${ERROR_COLOR}You are already using LXD. Setting it up again will destroy all your existing LXD images and containers.${NC}"
                echo -n "${ERROR_COLOR}Are you sure you wish to continue? (y/n) ${NC}"
                read REPLY
                echo
                if [ "$REPLY" = y ]
                then
                    ALL_LXD_CONTAINERS=$(lxc list -cn | grep -v "\-\-\-\-" | grep -v NAME | cut -d ' ' -f 2)
                    ALL_LXD_IMAGES=$(lxc image list | grep -v "\-\-\-\-" | grep -v ALIAS | cut -d '|' -f 3)
                    if [ -n "$ALL_LXD_CONTAINERS" ] ; then
                        lxc delete -f $ALL_LXD_CONTAINERS
                    fi
                    for image in $ALL_LXD_IMAGES ; do
                        lxc image delete $image
                    done
                else
                    exit 0
                fi
            fi
            setup_lxd
        ;;
        new)
            check_command_parameter_count 0 1
            enter_new_or_detect_package $1
            variables
            ensure_container
        ;;
        delete)
            check_command_parameter_count 0 1
            enter_or_detect_package $1
            variables
            delete_container
        ;;
        shell)
            check_command_parameter_count 0 1
            enter_new_or_detect_package $1
            variables
            ensure_container
            shell_container
        ;;
        source)
            PACKAGE=$1
            if [ -z "$PACKAGE" ] ; then
                echo "${ERROR_COLOR}Command 'source' requires a package name: $PROGRAM_NAME source PACKAGE_NAME${NC}"
                exit 1
            fi
            check_command_parameter_count 1 1
            # FIXME: should fail if $PACKAGE already exists and is not empty
            mkdir -p $PACKAGE
            cd $PACKAGE
            variables
            ensure_container
            get_source_package
        ;;
        dependencies)
            NEW_BUILD=1
            check_command_parameter_count 0 1
            enter_or_detect_package $1
            variables
            ensure_container
            exec_container rm -f $USERDIR/dependencies_installed
            install_dependencies
        ;;
        inst-foreign)
            check_command_parameter_count 1 1
            enter_new_or_detect_package
            variables
            install_foreign $1
        ;;
        build)
            NEW_BUILD=1
            PACKAGES=$@
            if [ -z "$PACKAGES" ] ; then
                enter_or_detect_package $1
                variables
                ensure_container
                install_dependencies
                build
            else
                if [ -n "$NO_DEB" ] ; then
                    echo "${ERROR_COLOR}Building dependent packages with the --no-deb option is not supported yet.${NC}"
                    exit 1
                fi

                for package in $PACKAGES ; do
                    enter_or_detect_package $package
                    variables
                    ensure_container
                    if [ -n "$PREVIOUS_BUILD_FOLDER" ] ; then
                        copy_build_to_container $PREVIOUS_BUILD_FOLDER $PREVIOUS_DEBS_TARBALL
                        exec_container rm -f $USERDIR/dependencies_installed
                    fi
                    install_dependencies
                    build
                    PREVIOUS_BUILD_FOLDER=$PWD
                    PREVIOUS_DEBS_TARBALL=$DEBS_TARBALL
                done
            fi
            stop_container
        ;;
        clean)
            check_command_parameter_count 0 1
            enter_or_detect_package $1
            variables
            ## start_container
            clean
        ;;
        deploy)
            check_command_parameter_count 0 1
            enter_or_detect_package $1
            variables
            deploy_to_device
        ;;
        *)
            display_help
            echo ""
            echo "${ERROR_COLOR}error: unknown command: $COMMAND${NC}"
            exit 1
        ;;
    esac
fi;
